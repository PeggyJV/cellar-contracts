// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.13;

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { MockLendingPool } from "./MockLendingPool.sol";
import { Math } from "src/utils/Math.sol";

library WadRayMath {
    uint256 public constant RAY = 1e27;
    uint256 public constant HALF_RAY = RAY / 2;

    /**
     * @dev Divides two ray, rounding half up to the nearest ray
     * @param a Ray
     * @param b Ray
     * @return The result of a/b, in ray
     **/
    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "cannot divide by zero");
        uint256 halfB = b / 2;

        require(a <= (type(uint256).max - halfB) / RAY, "math multiplication overflow");

        return (a * RAY + halfB) / b;
    }

    /**
     * @dev Multiplies two ray, rounding down to the nearest ray
     * @param a Ray
     * @param b Ray
     * @return The result of a*b, in ray
     **/
    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0 || b == 0) return 0;

        require(a <= (type(uint256).max - HALF_RAY) / b, "math multiplication overflow");

        return (a * b + HALF_RAY) / RAY;
    }
}

contract MockAToken is ERC20 {
    address public underlyingAsset;
    MockLendingPool public lendingPool;

    constructor(
        address _lendingPool,
        address _underlyingAsset,
        string memory _symbol
    ) ERC20(_symbol, _symbol) {
        lendingPool = MockLendingPool(_lendingPool);
        underlyingAsset = _underlyingAsset;
    }

    function decimals() public view override returns (uint8) {
        return ERC20(underlyingAsset).decimals();
    }

    function mint(address user, uint256 amount) external {
        uint256 amountScaled = WadRayMath.rayDiv(amount, lendingPool.index());
        require(amountScaled != 0, "CT_INVALID_MINT_AMOUNT");
        _mint(user, amountScaled);
    }

    function burn(address user, uint256 amount) external {
        uint256 amountScaled = WadRayMath.rayDiv(amount, lendingPool.index());
        require(amountScaled != 0, "CT_INVALID_BURN_AMOUNT");
        _burn(user, amountScaled);
    }

    /**
     * @dev Mints aTokens to `user`
     * - Only callable by the LendingPool, as extra state updates there need to be managed
     * @param user The address receiving the minted tokens
     * @param amount The amount of tokens getting minted
     * @param index The new liquidity index of the reserve
     * @return `true` if the the previous balance of the user was 0
     */
    function mint(
        address user,
        uint256 amount,
        uint256 index
    ) external returns (bool) {
        uint256 previousBalance = super.balanceOf(user);

        uint256 amountScaled = WadRayMath.rayDiv(amount, index);
        require(amountScaled != 0, "CT_INVALID_MINT_AMOUNT");
        _mint(user, amountScaled);

        return previousBalance == 0;
    }

    /**
     * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`
     * - Only callable by the LendingPool, as extra state updates there need to be managed
     * @param user The owner of the aTokens, getting them burned
     * @param receiverOfUnderlying The address that will receive the underlying
     * @param amount The amount being burned
     * @param index The new liquidity index of the reserve
     */
    function burn(
        address user,
        address receiverOfUnderlying,
        uint256 amount,
        uint256 index
    ) external {
        uint256 amountScaled = WadRayMath.rayDiv(amount, index);
        require(amountScaled != 0, "CT_INVALID_BURN_AMOUNT");
        _burn(user, amountScaled);

        ERC20(underlyingAsset).transfer(receiverOfUnderlying, amount);
    }

    /**
     * @dev Calculates the balance of the user: principal balance + interest generated by the principal
     * @param user The user whose balance is calculated
     * @return The balance of the user
     **/
    function balanceOf(address user) public view override returns (uint256) {
        return WadRayMath.rayMul(super.balanceOf(user), lendingPool.index());
    }

    /**
     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the
     * updated stored balance divided by the reserve's liquidity index at the moment of the update
     * @param user The user whose balance is calculated
     * @return The scaled balance of the user
     **/
    function scaledBalanceOf(address user) external view returns (uint256) {
        return super.balanceOf(user);
    }
}
